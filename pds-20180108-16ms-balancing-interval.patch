diff --git a/kernel/sched/pds.c b/kernel/sched/pds.c
index 326a9b6b8065..b46e57a21591 100644
--- a/kernel/sched/pds.c
+++ b/kernel/sched/pds.c
@@ -83,6 +83,12 @@
 
 #define MIN_VISIBLE_DEADLINE	(1 << 8)
 
+/*
+ * BALANCE_INTERVAL should be power of 2 for quick calculation
+ */
+#define BALANCE_INTERVAL	(MS_TO_NS(16ULL))
+#define BALANCE_INTERVAL_MASK	(~(BALANCE_INTERVAL - 1ULL))
+
 enum {
 	BASE_CPU_AFFINITY_CHK_LEVEL = 1,
 #ifdef CONFIG_SCHED_SMT
@@ -3140,7 +3146,7 @@ static inline bool pds_trigger_load_balance(struct rq *rq)
 	if (rq->clock < rq->next_balance)
 		return false;
 
-	rq->next_balance = rq->clock + MS_TO_NS(rr_interval);
+	rq->next_balance = (rq->clock & BALANCE_INTERVAL_MASK) + rq->balance_inc;
 
 	cpu = cpu_of(rq);
 	if (!cpumask_test_cpu(cpu, &sched_rq_pending_mask))
@@ -6127,6 +6133,11 @@ static void sched_init_topology_cpumask(void)
 	cpumask_t *chk;
 
 	for_each_online_cpu(cpu) {
+		cpu_rq(cpu)->balance_inc = BALANCE_INTERVAL +
+			BALANCE_INTERVAL / num_online_cpus() * cpu;
+
+		printk(KERN_INFO "pds: [%d] balance_inc 0x%llx", cpu,
+		       cpu_rq(cpu)->balance_inc);
 		chk = &sched_cpu_affinity_chk_masks[cpu][0];
 #ifdef CONFIG_SCHED_SMT
 		cpumask_copy(&tmp, topology_sibling_cpumask(cpu));
diff --git a/kernel/sched/pds_sched.h b/kernel/sched/pds_sched.h
index 213b71c44452..2963efc564e6 100644
--- a/kernel/sched/pds_sched.h
+++ b/kernel/sched/pds_sched.h
@@ -62,6 +62,7 @@ struct rq {
 	int cpu;		/* cpu of this runqueue */
 	bool online;
 	u64 next_balance;
+	u64 balance_inc;
 
 #ifdef CONFIG_SCHED_SMT
 	int active_balance;
